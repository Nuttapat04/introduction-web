<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Constellation | 3D Particles</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow-x: hidden;
            background-color: #050510;
            color: white;
        }

        canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            z-index: -1;
        }

        .scroll-content {
            height: 200vh;
        }

        /* Force scroll for zoom effect */
    </style>
</head>

<body class="font-mono">

    <!-- WebGL Canvas -->
    <canvas id="canvas"></canvas>

    <!-- Overlay UI -->
    <main class="relative z-10 pointer-events-none">
        <div class="h-screen flex flex-col justify-center items-center text-center">
            <h1
                class="text-6xl md:text-8xl font-black tracking-tighter text-transparent bg-clip-text bg-gradient-to-b from-blue-300 to-purple-600 mb-4 drop-shadow-[0_0_15px_rgba(100,100,255,0.5)]">
                NEBULA
            </h1>
            <p class="text-sm md:text-base tracking-[0.5em] text-blue-200 opacity-70">
                PARTICLE GRAVITY SYSTEM
            </p>
            <div class="absolute bottom-10 animate-bounce text-blue-400 text-xs tracking-widest">
                SCROLL TO WARP
            </div>
        </div>

        <div class="h-screen flex items-center justify-center">
            <div
                class="bg-black/80 backdrop-blur-md p-8 md:p-12 border border-blue-500/30 rounded-2xl max-w-2xl text-center">
                <h2 class="text-3xl font-bold mb-4 text-purple-300">Singularity Reached</h2>
                <p class="text-gray-400 leading-relaxed mb-6">
                    You have entered the core of the system.
                    The particles react to your presence, scattering upon contact and reforming in the void.
                </p>
                <div
                    class="text-xs text-blue-500 uppercase tracking-widest border border-blue-500/50 px-4 py-2 inline-block rounded-full">
                    Systems Normal
                </div>
            </div>
        </div>
    </main>

    <!-- Three.js Logic -->
    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

        // 1. Scene Setup
        const canvas = document.querySelector('#canvas');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050510, 0.002);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 30;

        const renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        // 2. Particle System
        const particlesGeometry = new THREE.BufferGeometry();
        const particlesCount = 5000;

        const posArray = new Float32Array(particlesCount * 3);
        const originalPosArray = new Float32Array(particlesCount * 3); // Store original buffer to return to

        // Create Sphere Shape
        const sphereRadius = 10;
        for (let i = 0; i < particlesCount; i++) {
            // Random point on sphere surface (or volume)
            // Using spherical coordinates for better distribution
            const phi = Math.acos(-1 + (2 * i) / particlesCount);
            const theta = Math.sqrt(particlesCount * Math.PI) * phi;

            // Add some noise (volume)
            const r = sphereRadius + (Math.random() - 0.5) * 2;

            const x = r * Math.cos(theta) * Math.sin(phi);
            const y = r * Math.sin(theta) * Math.sin(phi);
            const z = r * Math.cos(phi);

            posArray[i * 3] = x;
            posArray[i * 3 + 1] = y;
            posArray[i * 3 + 2] = z;

            originalPosArray[i * 3] = x;
            originalPosArray[i * 3 + 1] = y;
            originalPosArray[i * 3 + 2] = z;
        }

        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));

        // Material
        // Create a circular sprite for particles
        const sprite = new THREE.TextureLoader().load('https://assets.codepen.io/127738/dotTexture.png');

        const material = new THREE.PointsMaterial({
            size: 0.15,
            map: sprite,
            transparent: true,
            color: 0x88ccff,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            vertexColors: false // We use single color for now, can be upgraded
        });

        const particlesMesh = new THREE.Points(particlesGeometry, material);
        scene.add(particlesMesh);

        // 3. Interaction Logic
        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        const targetPos = new THREE.Vector3(); // Mouse in 3D space projection

        // Mouse Move
        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        });

        // Scroll Logic (Zoom)
        let scrollY = 0;
        window.addEventListener('scroll', () => {
            scrollY = window.scrollY;
        });

        // 4. Animation Loop
        const clock = new THREE.Clock();

        function animate() {
            const elapsedTime = clock.getElapsedTime();

            // Auto Rotation
            particlesMesh.rotation.y = elapsedTime * 0.05;
            particlesMesh.rotation.x = elapsedTime * 0.02;

            // Scroll Zoom
            // Normalize scroll to move camera from z=30 closer to center
            const zoom = scrollY * 0.02;
            camera.position.z = Math.max(5, 30 - zoom);
            // Also rotate system faster on scroll
            particlesMesh.rotation.z = scrollY * 0.001;

            // Interactive Repulsion (Explosion)
            // Raycast to find point on invisible plane or just project mouse? 
            // Simple approach: Unproject mouse to z=0 plane or just use screen space logic if simple.
            // Better: Raycast a plane at z=0 to get 3D mouse coord.
            raycaster.setFromCamera(mouse, camera);
            const intersectionPoint = new THREE.Vector3();
            // Approximating mouse position on the plane where sphere is roughly located
            raycaster.ray.at(camera.position.z - 0, intersectionPoint);

            // We need to transform intersection point into the Local Space of the mesh 
            // for accurate distance since the mesh rotates. 
            // Actually, simpler to modify Geometry in World Space? NO, expensive.
            // Let's modify buffer attribute.

            // To do this performantly in CPU for 5000 particles is okay.

            const positions = particlesGeometry.attributes.position.array;

            // We need to inverse the rotation of the mesh to compare with local positions
            // Or apply rotation to positions.
            // Let's approximate: Transform mouse to local space.
            const localMouse = intersectionPoint.clone().applyMatrix4(particlesMesh.matrixWorld.invert());

            for (let i = 0; i < particlesCount; i++) {
                const i3 = i * 3;

                // Current position
                const x = positions[i3];
                const y = positions[i3 + 1];
                const z = positions[i3 + 2];

                // Original position
                const ox = originalPosArray[i3];
                const oy = originalPosArray[i3 + 1];
                const oz = originalPosArray[i3 + 2];

                // Distance to mouse (squared for perf)
                const dx = x - localMouse.x;
                const dy = y - localMouse.y;
                const dz = z - localMouse.z;
                const distSq = dx * dx + dy * dy + dz * dz;

                const repulsionRadius = 25.0; // Radius of influence
                const force = 3.0; // Strength

                if (distSq < repulsionRadius) {
                    const dist = Math.sqrt(distSq);
                    const angle = Math.atan2(dy, dx);
                    // Also z component... 
                    // Normalize direction vector
                    const nx = dx / dist;
                    const ny = dy / dist;
                    const nz = dz / dist;

                    // Push away
                    positions[i3] += nx * force * 0.1;
                    positions[i3 + 1] += ny * force * 0.1;
                    positions[i3 + 2] += nz * force * 0.1;
                } else {
                    // Return to original
                    // Lerp back
                    positions[i3] += (ox - x) * 0.05;
                    positions[i3 + 1] += (oy - y) * 0.05;
                    positions[i3 + 2] += (oz - z) * 0.05;
                }
            }

            particlesGeometry.attributes.position.needsUpdate = true;

            // Pulse color
            const hue = (elapsedTime * 0.05) % 1;
            // material.color.setHSL(0.6 + hue * 0.1, 0.8, 0.6); // Subtle shift in blue/purple range

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        animate();

        // 5. Resize Handling
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>

</html>